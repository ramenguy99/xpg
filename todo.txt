Python:
[ ] Imgui bindings with dear_bindings:
    -> json file looks straight forward for binding gen, nice that we can match API 1 to 1 with what we use in xpg
    -> not yet clear if we can also do ImPlot with this, or if we need internal stuff too. But good starting point.
    -> also not clear what stuff goes to python and what goes to nanonbind autogenned bindings
        -> we definitely want python stubs for autocomplete experience
        -> we probably dont want to do weird cython / ffi stuff in python
        -> we probably want to autogen implementation of the nanobind bindings on the C++ side
        -> we probably want a set of manually generated pythonic helpers for commonly used stuff
[ ] gfx and gui bindings for window / vulkan / gui
[ ] Slang bindings for compiling and for reflection
[ ] Framegraph implementation on top of reflection for easy prototyping of pipelines/shaders
    -> interesting here would be how much perf we can have when sharing data through arrays, e.g. textures, buffers, uniforms
    -> also interesting if we want to have a full python framegraph or if we can somehow leverage python callables
       + some python bindings to reuse at least the synchronization / traversal logic implemented in C++

Backlog:
[x] Rename lru cache
[x] Cleanup project structure:
    [x] Fix build and cleanup all of them
    [x] One directory per sample app
    [x] Normal build instead of unity?
[ ] minimal app (multiple hooks seem to be needed, e.g. pre-gui, post-gui at least, maybe should just be a single loop one? but then more dup?)

Ideas:
- Maybe have an internal feature set kind of thing to support multiple hardware types.
  Seem important to support at least:
    - Compute only (required: subgroup stuff?)
    - Basic rendering (required: dynamic rendering?)
    - Raytracing (required: rt + bindless)

- New error model for everything:
    - Error on the handle kind of thing
    - Ability to attach context and record call stacks
    - Maybe helpers / macros to check if an handle is errored and collect callstacks / attach additional info.

- Cleaness and portability:
    - Statically link on windows and with musl on linux (no idea about macOS)
    - Get rid of some headers
    - Maybe split stuff in some cpp files

Notes:
- Add python library target and test nanobind + pybind11 stubs generator for generating and packaging python module
    - Python module interface (similar to viewer needs):
        - Window utilities (multiple windows, surface rendering without window / swapchains)
        - Rendering logic and scene hierarchy/renderables likely defined in C++ code and exposed to python. (Maybe add wrappers for conversions/utils that are easier to do in python).
        - Debugging options at runtime (e.g. logging / tracing / validation / named objects etc..)
- Targets (share as much code as possible):
    - Standalone apps in C++.
    - Scriptable apps from python.
    - Headless rendering/compute from C++/python.
- Initialize vulkan stuff and build rendering layer utilities on top of it.
    - Required extensions?
    - ImGui/docking support -> use same GUI version as pyimgui and share ctx somehow, or make our own bindings.
    - Render on resize mode?
    - Binding helpers?
    - Synchronization / render passes?
    - Resource / memory management (VMA)?
    - Ring/buffers?
    - Ray-tracing?
- Shaders:
    - HLSL/GLSL/SLANG? -> all require toolchain to be installed for development
    - Need introspection?
    - Hot reloading?
- Test on linux/macos.


Project structure:
- Core:
    - Vulkan context and headless rendering
    - Resource creation and other utils
    - Shader and pipeline management helpers
    - Maybe a rendergraph helper here too?
- Viewer:
    - Windowing
    - ImGui
    - Input
    - Renderables and passes

- Python module:
    - Bindings for both core and viewer

 Core    -
  |        \
  |          -> Python bindings + conversion utils -> python wrappers/helpers -> user code
  V        /
Viewer   -




Initializers notes:

Likely ok to have an extra read-only span for this, ArrayView
is inherently read-write.
We can also delete copy constructor stuff ehere that allows
it to be even more typechecked (cannot create with initializer list and then assign when list is destroyed)
struct A {
    int a;
};

This is would also be nice, but unfortunately the c++ compiler cant reason about it when
it's inside a struct, only as top level param. Guess we gotta dynamically allocate.
template<typename T, size_t N>
using SpanFixed = T[N];

template<typename T>
struct Span {
    const T* data;
    size_t length;

    Span(std::initializer_list<T> l) {
        data = l.begin();
        length = l.size();
    }

    Span(const Span& other) = delete;
    Span& operator=(const Span& other) = delete;
};

struct B {
    A a;
    Span<int> span;
};

void construct_safe(const B&& b) {
}
B b = {
    .a = {.a = 5},
    .span = { 1, 2, 3 },
};

Span s = { 1, 2, 3 };
construct_safe({
    .a = {.a = 5},
    .span = { 1, 2, 3},
});

Span span = { 1, 2, 3 };
construct_safe({
    .a = {.a = 5},
    .span = std::move(span),
});

