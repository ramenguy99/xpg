Backlog:
[x] Rename lru cache
[ ] Cleanup project structure:
    [ ] Fix build and cleanup all of them
    [ ] One directory per sample app
    [ ] Normal build instead of unity?
[ ] minimal app (multiple hooks seem to be needed, e.g. pre-gui, post-gui at least, maybe should just be a single loop one? but then more dup?)

Ideas:
- Maybe have an internal feature set kind of thing to support multiple hardware types.
  Seem important to support at least:
    - Compute only (required: subgroup stuff?)
    - Basic rendering (required: dynamic rendering?)
    - Raytracing (required: rt + bindless)

- New error model for everything:
    - Error on the handle kind of thing
    - Ability to attach context and record call stacks
    - Maybe helpers / macros to check if an handle is errored and collect callstacks / attach additional info.

- Cleaness and portability:
    - Statically link on windows and with musl on linux (no idea about macOS)
    - Get rid of some headers
    - Maybe split stuff in some cpp files

Notes:
- Add python library target and test nanobind + pybind11 stubs generator for generating and packaging python module
    - Python module interface (similar to viewer needs):
        - Window utilities (multiple windows, surface rendering without window / swapchains)
        - Rendering logic and scene hierarchy/renderables likely defined in C++ code and exposed to python. (Maybe add wrappers for conversions/utils that are easier to do in python).
        - Debugging options at runtime (e.g. logging / tracing / validation / named objects etc..)
- Targets (share as much code as possible):
    - Standalone apps in C++.
    - Scriptable apps from python.
    - Headless rendering/compute from C++/python.
- Initialize vulkan stuff and build rendering layer utilities on top of it.
    - Required extensions?
    - ImGui/docking support -> use same GUI version as pyimgui and share ctx somehow, or make our own bindings.
    - Render on resize mode?
    - Binding helpers?
    - Synchronization / render passes?
    - Resource / memory management (VMA)?
    - Ring/buffers?
    - Ray-tracing?
- Shaders:
    - HLSL/GLSL/SLANG? -> all require toolchain to be installed for development
    - Need introspection?
    - Hot reloading?
- Test on linux/macos.


Project structure:
- Core:
    - Vulkan context and headless rendering
    - Resource creation and other utils
    - Shader and pipeline management helpers
    - Maybe a rendergraph helper here too?
- Viewer:
    - Windowing
    - ImGui
    - Input
    - Renderables and passes

- Python module:
    - Bindings for both core and viewer

 Core    - 
  |        \
  |          -> Python bindings + conversion utils -> python wrappers/helpers -> user code
  V        / 
Viewer   -




Initializers notes:

Likely ok to have an extra read-only span for this, ArrayView
is inherently read-write.
We can also delete copy constructor stuff ehere that allows
it to be even more typechecked (cannot create with initializer list and then assign when list is destroyed)
struct A {
    int a;
};

This is would also be nice, but unfortunately the c++ compiler cant reason about it when
it's inside a struct, only as top level param. Guess we gotta dynamically allocate.
template<typename T, size_t N>
using SpanFixed = T[N];

template<typename T>
struct Span {
    const T* data;
    size_t length;

    Span(std::initializer_list<T> l) {
        data = l.begin();
        length = l.size();
    }

    Span(const Span& other) = delete;
    Span& operator=(const Span& other) = delete;
};

struct B {
    A a;
    Span<int> span;
};

void construct_safe(const B&& b) {
}
B b = {
    .a = {.a = 5},
    .span = { 1, 2, 3 },
};

Span s = { 1, 2, 3 };
construct_safe({
    .a = {.a = 5},
    .span = { 1, 2, 3},
});

Span span = { 1, 2, 3 };
construct_safe({
    .a = {.a = 5},
    .span = std::move(span),
});

